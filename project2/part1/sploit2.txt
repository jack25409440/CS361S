The for loop in target2.c sets the condition as i<=len and so there is a one byte overflow on the $ebp. Notice that the $ebp overflowed is the $ebp in bar function. The return address, which is the begining of string "out", is stored in 0xbffffd34 (attack[296-299]) and the overwriting byte is attack[300]. It changes the $ebp register to 0xbffffd30. When function returns, the leave instruction first set $esp=$ebp and pops the old $ebp back to $ebp register Then $esp=$esp+4. The return address then is fetched using $esp and the function returns. Therefore by changing $ebp, the function returns to the address I want.
